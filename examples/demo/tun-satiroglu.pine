// © beytun
// https://www.tradingview.com/script/PKYrwXtg-Tun%C3%A7-%C5%9Eat%C4%B1ro%C4%9Flu/

//@version=6
indicator('Tunç Şatıroğlu', overlay = false, max_lines_count=500, max_labels_count=500, max_bars_back=1000)

//@description This script combines five TradingView community indicators and one built-in indicator frequently used by Tunç Şatıroğlu in his technical analysis training, integrated into a single suite for comprehensive analysis. Each indicator has been modified to enhance functionality, usability, or performance:

//@description - WaveTrend with Crosses by LazyBear (https://www.tradingview.com/script/jFQn4jYZ-WaveTrend-with-Crosses-LazyBear/), modified to improve user experience
//@description - Kaufman Moving Average Adaptive (KAMA) by HPotter (https://www.tradingview.com/script/RsdQHpdq-Kaufman-Moving-Average-Adaptive-KAMA/), used with permission of HPotter, modified to improve user experience
//@description - SuperTrend by Alex Orekhov (https://www.tradingview.com/script/VLWVV7tH-SuperTrend/), used with permission under GPL-3.0, modified to improve user experience
//@description - Nadaraya-Watson Envelope by LuxAlgo (https://www.tradingview.com/script/Iko0E2kL-Nadaraya-Watson-Envelope-LuxAlgo/), licensed under CC BY-NC-SA 4.0, modified to improve user experience
//@description - Divergence for Many Indicators v4 by LonesomeTheBlue (https://www.tradingview.com/script/n8AGnIZd-Divergence-for-Many-Indicators-v4/), licensed under MPL 2.0, modified to improve user experience
//@description - Ichimoku Cloud, built-in TradingView indicator (https://www.tradingview.com/support/solutions/43000502040/), modified to improve user experience

//@description The script consolidates these enhanced indicators to align with Şatıroğlu's training approach, offering a unified tool for trend, momentum, divergence, and multi-timeframe analysis.

//@description Note: The Nadaraya-Watson Envelope may repaint in its default mode; use the 'Repainting Smoothing' option to disable repainting if preferred.
//@description Note: The Nadaraya-Watson Envelope and Ichimoku Cloud may repaint in their default modes; use the 'Repainting Smoothing' option for Nadaraya-Watson or adjust Ichimoku settings to mitigate repainting if preferred.

//@description License: This combined script is published under the MIT License. See below for details.
//@license MIT License (https://opensource.org/licenses/MIT)
//@license Includes code from SuperTrend under GPL-3.0 (https://www.gnu.org/licenses/gpl-3.0.en.html)
//@license Includes code from Nadaraya-Watson Envelope under CC BY-NC-SA 4.0 (https://creativecommons.org/licenses/by-nc-sa/4.0/)
//@license Includes code from Divergence for Many Indicators v4 under MPL 2.0 (https://mozilla.org/MPL/2.0/)
//@license Includes modified built-in Ichimoku Cloud indicator, property of TradingView; used and modified per TradingView's platform terms.

// © beytun

//@returns A suite of indicators for trend, momentum and divergence analysis.

// === INDICATORS
enableWaveTrend = input.bool(true, 'WaveTrend', group = 'INDICATORS')
enableKAMA = input.bool(true, 'KAMA', group='INDICATORS')
enableSuperTrend = input.bool(true, 'SuperTrend', group='INDICATORS')
enableNadarayaWatson = input.bool(true, 'Nadaraya-Watson', group='INDICATORS')
enableDivergence = input.bool(true, 'Divergence for Many Indicators', group='INDICATORS')
enableIchimoku = input.bool(false, 'Ichimoku Cloud', group='INDICATORS')

// ===============================================================================================================
// === WaveTrend with Crosses by LazyBear ===
// Source: https://www.tradingview.com/script/jFQn4jYZ-WaveTrend-with-Crosses-LazyBear/
// Used with open-source permissions; original author credited.
// Note: Modified to improve user experience.
n1 = input.int(10, 'Channel Length', group = 'WaveTrend')
n2 = input.int(21, 'Average Length', group = 'WaveTrend')
obLevel1 = input.int(60, 'Overbought Level 1', group = 'WaveTrend')
obLevel2 = input.int(53, 'Overbought Level 2', group = 'WaveTrend')
osLevel1 = input.int(-60, 'Oversold Level 1', group = 'WaveTrend')
osLevel2 = input.int(-53, 'Oversold Level 2', group = 'WaveTrend')

ap = hlc3
esa = ta.ema(ap, n1)
d = ta.ema(math.abs(ap - esa), n1)
ci = (ap - esa) / (0.015 * d)
tci = ta.ema(ci, n2)
wt1 = tci
wt2 = ta.sma(wt1, 4)

// Plot WaveTrend in a separate pane
plot(enableWaveTrend ? 0 : na, color = color.gray, title = 'WaveTrend - Zero Line')
plot(enableWaveTrend ? obLevel1 : na, color = color.red, title = 'WaveTrend - Overbought Level 1')
plot(enableWaveTrend ? osLevel1 : na, color = color.green, title = 'WaveTrend - Oversold Level 1')
plot(enableWaveTrend ? obLevel2 : na, color = color.red, title = 'WaveTrend - Overbought Level 2')
plot(enableWaveTrend ? osLevel2 : na, color = color.green, title = 'WaveTrend - Oversold Level 2')
plot(enableWaveTrend ? wt1 : na, color = color.green, title = 'WaveTrend - Oscillator')
plot(enableWaveTrend ? wt2 : na, color = color.red, title = 'WaveTrend - Signal')
plot(enableWaveTrend ? wt1 - wt2 : na, color = color.new(color.blue, 80), style = plot.style_area, title = 'WaveTrend - Histogram')

wt_cross = ta.cross(wt1, wt2)
plot(enableWaveTrend ? (wt_cross ? wt2 : na) : na, color = color.new(color.white, 60), style = plot.style_circles, linewidth = 3, title = 'WaveTrend - Cross Boundary')
plot(enableWaveTrend ? (wt_cross ? wt2 : na) : na, color = (wt2 - wt1 > 0 ? color.red : color.lime), style = plot.style_circles, linewidth = 2, title = 'WaveTrend - Cross Fills')

// Bar Color Highlights on the price chart
barcolor(enableWaveTrend ? (wt_cross ? (wt2 - wt1 > 0 ? color.rgb(0, 255, 255) : color.yellow) : na) : na, title = 'WaveTrend - Bar Colors')

// ===============================================================================================================
// === KAMA by HPotter ===
// Source: https://www.tradingview.com/script/RsdQHpdq-Kaufman-Moving-Average-Adaptive-KAMA/
// Used with explicit permission from HPotter.
// Note: Modified to improve user experience.
Length = input.int(21, 'Length', 1, group='KAMA')
xPrice = close
xvnoise = math.abs(xPrice - xPrice[1])
nAMA = 0.0
nfastend = 0.666
nslowend = 0.0645
nsignal = math.abs(xPrice - xPrice[Length])
nnoise = math.sum(xvnoise, Length)
nefratio = nnoise != 0 ? nsignal / nnoise : 0
nsmooth = math.pow(nefratio * (nfastend - nslowend) + nslowend, 2)
nAMA := nz(nAMA[1]) + nsmooth * (xPrice - nz(nAMA[1]))

// Plot KAMA on the price chart by using force_overlay
plot(enableKAMA ? nAMA : na, color = color.rgb(187, 217, 251), linewidth = 2, title = 'KAMA - Indicator', force_overlay = true)

// ===============================================================================================================
// === SuperTrend by Alex Orekhov ===
// Source: https://www.tradingview.com/script/VLWVV7tH-SuperTrend/
// Copyright (c) 2019-present, Alex Orekhov (everget)
// Used with explicit permission; licensed under GPL-3.0 (https://www.gnu.org/licenses/gpl-3.0.en.html)
// Note: Modified to improve user experience.
length = input.int(22, 'ATR Period', group='SuperTrend')
mult = input.float(3, 'ATR Multiplier', step=0.1, group='SuperTrend')
src = input.source(hl2, 'Source', group='SuperTrend')
wicks = input.bool(false, 'Take Wicks Into Account', group='SuperTrend')
showLabels = input.bool(true, 'Show Buy/Sell Labels', group='SuperTrend')
highlightState = input.bool(true, 'Highlight State', group='SuperTrend')

atr = mult * ta.atr(length)

highPrice = wicks ? high : close
lowPrice = wicks ? low : close
doji4price = open == close and open == low and open == high

longStop = src - atr
longStopPrev = nz(longStop[1], longStop)

if longStop > 0
    if doji4price
        longStop := longStopPrev
    else
        longStop := lowPrice[1] > longStopPrev ? math.max(longStop, longStopPrev) : longStop
else
    longStop := longStopPrev

shortStop = src + atr
shortStopPrev = nz(shortStop[1], shortStop)

if shortStop > 0
    if doji4price
        shortStop := shortStopPrev
    else
        shortStop := highPrice[1] < shortStopPrev ? math.min(shortStop, shortStopPrev) : shortStop
else
    shortStop := shortStopPrev

var int dir = 1
dir := dir == -1 and highPrice > shortStopPrev ? 1 : dir == 1 and lowPrice < longStopPrev ? -1 : dir

var color longColor = color.new(color.green, 90)
var color shortColor = color.new(color.red, 90)

longStopPlot = plot(enableSuperTrend ? (dir == 1 ? longStop : na) : na, title = 'SuperTrend - Long Stop', style = plot.style_linebr, linewidth = 2, color = color.new(longColor, 0), force_overlay = true)
buySignal = dir == 1 and dir[1] == -1
plotshape(enableSuperTrend ? (buySignal ? longStop : na) : na, title = 'SuperTrend - Long Stop Start', location = location.absolute, style = shape.circle, size = size.tiny, color = color.new(longColor, 0), force_overlay = true)
plotshape(enableSuperTrend ? (buySignal and showLabels ? longStop : na) : na, title = 'SuperTrend - Buy Label', text = 'Buy', location = location.absolute, style = shape.labelup, size = size.tiny, color = color.new(longColor, 0), textcolor = color.new(color.white, 0), force_overlay = true)

shortStopPlot = plot(enableSuperTrend ? (dir == 1 ? na : shortStop) : na, title = 'SuperTrend - Short Stop', style = plot.style_linebr, linewidth = 2, color = color.new(shortColor, 0), force_overlay = true)
sellSignal = dir == -1 and dir[1] == 1
plotshape(enableSuperTrend ? (sellSignal ? shortStop : na) : na, title = 'SuperTrend - Short Stop Start', location = location.absolute, style = shape.circle, size = size.tiny, color = color.new(shortColor, 0), force_overlay = true)
plotshape(enableSuperTrend ? (sellSignal and showLabels ? shortStop : na) : na, title = 'SuperTrend - Sell Label', text = 'Sell', location = location.absolute, style = shape.labeldown, size = size.tiny, color = color.new(shortColor, 0), textcolor = color.new(color.white, 0), force_overlay = true)

midPricePlot = plot(enableSuperTrend ? ohlc4 : na, title = 'SuperTrend - Mid Price', style = plot.style_circles, linewidth = 1, display = display.none, editable = false, force_overlay = true)

longFillColor = highlightState ? dir == 1 ? longColor : na : na
shortFillColor = highlightState ? dir == -1 ? shortColor : na : na
fill(midPricePlot, longStopPlot, title = 'SuperTrend - Long State Filling', color = enableSuperTrend ? longFillColor : na)
fill(midPricePlot, shortStopPlot, title = 'SuperTrend - Short State Filling', color = enableSuperTrend ? shortFillColor : na)

changeCond = dir != dir[1]
alertcondition(changeCond, title = 'Alert: SuperTrend Direction Change', message = 'SuperTrend has changed direction!\nSymbol: {{exchange}}:{{ticker}}\nPrice: {{close}}')
alertcondition(buySignal, title = 'Alert: SuperTrend Buy', message = 'SuperTrend Buy!\nSymbol: {{exchange}}:{{ticker}}\nPrice: {{close}}')
alertcondition(sellSignal, title = 'Alert: SuperTrend Sell', message = 'SuperTrend Sell!\nSymbol: {{exchange}}:{{ticker}}\nPrice: {{close}}')

// ===============================================================================================================
// === Nadaraya-Watson Envelope by LuxAlgo ===
// Source: https://www.tradingview.com/script/Iko0E2kL-Nadaraya-Watson-Envelope-LuxAlgo/
// This work is licensed under a Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0)
// https://creativecommons.org/licenses/by-nc-sa/4.0/
// © LuxAlgo
// Note: Modified to improve user experience.
// Note: This indicator may repaint in its default mode. Disable 'Repainting Smoothing' for non-repainting output.

//------------------------------------------------------------------------------
//Settings
//-----------------------------------------------------------------------------{
h = input.float(8., 'Bandwidth', minval=0, group='Nadaraya-Watson Envelope')
multiplier = input.float(3., 'Multiplier', minval=0, group='Nadaraya-Watson Envelope')
source = input.source(close, 'Source', group='Nadaraya-Watson Envelope')
repaint = input.bool(true, 'Repainting Smoothing', tooltip='Repainting is an effect where the indicators historical output is subject to change over time. Disabling repainting will cause the indicator to output the endpoints of the calculations', group='Nadaraya-Watson Envelope')

//Style
showPaneLabels = input.bool(false, 'Show Pane Labels', group='Nadaraya-Watson Envelope')
upCss = input.color(color.teal, 'Colors', inline='inline1', group='Nadaraya-Watson Envelope')
dnCss = input.color(color.red, '', inline='inline1', group='Nadaraya-Watson Envelope')

//-----------------------------------------------------------------------------}
//Functions
//-----------------------------------------------------------------------------{
//Gaussian window
gauss(x, h) => math.exp(-(math.pow(x, 2) / (h * h * 2)))

//-----------------------------------------------------------------------------}
//Append lines
//-----------------------------------------------------------------------------{
n = bar_index

var line[] ln = array.new<line>(0)

if barstate.isfirst and repaint and enableNadarayaWatson
    for i = 0 to 499
        array.push(ln, line.new(na, na, na, na))

//-----------------------------------------------------------------------------}
//End point method
//-----------------------------------------------------------------------------{
var float[] coefs = array.new<float>(0)
var float den = 0.

if barstate.isfirst and not repaint and enableNadarayaWatson
    for i = 0 to 499
        w = gauss(i, h)
        array.push(coefs, w)

    den := array.sum(coefs)

out = 0.
if not repaint and enableNadarayaWatson
    for i = 0 to 499
        out += source[i] * array.get(coefs, i)
out /= den
mae = ta.sma(math.abs(source - out), 499) * multiplier

upper = out + mae
lower = out - mae

//-----------------------------------------------------------------------------}
//Compute and display NWE
//-----------------------------------------------------------------------------{
var float y2 = na
var float y1 = na

var float[] nwe = array.new<float>(0)
if barstate.islast and repaint and enableNadarayaWatson
    sae = 0.
    //Compute and set NWE point
    for i = 0 to math.min(499, n - 1)
        sum = 0.
        sumw = 0.
        //Compute weighted mean
        for j = 0 to math.min(499, n - 1)
            w = gauss(i - j, h)
            sum += source[j] * w
            sumw += w

        y2 := sum / sumw
        sae += math.abs(source[i] - y2)
        array.push(nwe, y2)
    
    sae := sae / math.min(499, n - 1) * multiplier
    for i = 0 to math.min(499, n - 1)
        if i % 2 == 1
            line.new(x1=n-i+1, y1=y1 + sae, x2=n-i, y2=array.get(nwe, i) + sae, color=upCss, force_overlay = true)
            line.new(x1=n-i+1, y1=y1 - sae, x2=n-i, y2=array.get(nwe, i) - sae, color=dnCss, force_overlay = true)
        
        if showPaneLabels and source[i] > array.get(nwe, i) + sae and source[i+1] < array.get(nwe, i) + sae
            label.new(x=n-i, y=source[i], text='▼', color=color.new(color.white, 100), style=label.style_label_down, textcolor=dnCss, textalign=text.align_center, force_overlay = true)
        if showPaneLabels and source[i] < array.get(nwe, i) - sae and source[i+1] > array.get(nwe, i) - sae
            label.new(x=n-i, y=source[i], text='▲', color=color.new(color.white, 100), style=label.style_label_up, textcolor=upCss, textalign=text.align_center, force_overlay = true)
        
        y1 := array.get(nwe, i)

//-----------------------------------------------------------------------------}
//Dashboard
//-----------------------------------------------------------------------------{
var table tb = table.new(position.top_right, columns=1, rows=1
  , bgcolor=#1e222d
  , border_color=#373a46
  , border_width=1
  , frame_color=#373a46
  , frame_width=1
  , force_overlay = true)

if repaint and enableNadarayaWatson
    table.cell(tb, 0, 0, text='Repainting Mode Enabled', text_color=color.white, text_size=size.small)

//-----------------------------------------------------------------------------}
//Plot
//-----------------------------------------------------------------------------}
plot(enableNadarayaWatson ? (repaint ? na : out + mae) : na, title='Nadaraya-Watson - Upper', color=upCss, force_overlay = true)
plot(enableNadarayaWatson ? (repaint ? na : out - mae) : na, title='Nadaraya-Watson - Lower', color=dnCss, force_overlay = true)

//Crossing Arrows
plotshape(enableNadarayaWatson ? (ta.crossunder(close, out - mae) ? low : na) : na, title="Nadaraya-Watson - Crossunder", style=shape.labelup, location=location.absolute, color=color.new(color.white, 100), text='▲', textcolor=upCss, size=size.tiny, force_overlay=true, display=showPaneLabels ? display.pane : display.none)
plotshape(enableNadarayaWatson ? (ta.crossover(close, out + mae) ? high : na) : na, title="Nadaraya-Watson - Crossover", style=shape.labeldown, location=location.absolute, color=color.new(color.white, 100), text='▼', textcolor=dnCss, size=size.tiny, force_overlay=true, display=showPaneLabels ? display.pane : display.none)

//-----------------------------------------------------------------------------}

// ===============================================================================================================
// === Divergence for Many Indicators v4 by LonesomeTheBlue ===
// Source: https://www.tradingview.com/script/n8AGnIZd-Divergence-for-Many-Indicators-v4/
// Copyright © LonesomeTheBlue
// Licensed under Mozilla Public License 2.0 (https://mozilla.org/MPL/2.0/)
// Note: Modified to improve user experience.

prd = input.int(defval = 5, title = 'Pivot Period', minval = 1, maxval = 50, group='Divergence for Many Indicators')
sourceDivergence = input.source(close, 'Source for Pivot Points', group='Divergence for Many Indicators')
searchdiv = input.string(defval = 'Regular', title = 'Divergence Type', options = ['Regular', 'Hidden', 'Regular/Hidden'], group='Divergence for Many Indicators')
showindis = input.string(defval = 'Don\'t Show', title = 'Show Indicator Names', options = ['Full', 'First Letter', 'Don\'t Show'], group='Divergence for Many Indicators')
showlimit = input.int(1, title = 'Minimum Number of Divergence', minval = 1, maxval = 11, group='Divergence for Many Indicators')
maxpp = input.int(defval = 10, title = 'Maximum Pivot Points to Check', minval = 1, maxval = 20, group='Divergence for Many Indicators')
maxbars = input.int(defval = 100, title = 'Maximum Bars to Check', minval = 30, maxval = 200, group='Divergence for Many Indicators')
shownum = input(defval = true, title = 'Show Divergence Number', group='Divergence for Many Indicators')
showlast = input(defval = false, title = 'Show Only Last Divergence', group='Divergence for Many Indicators')
dontconfirm = input(defval = false, title = 'Don\'t Wait for Confirmation', group='Divergence for Many Indicators')
showlines = input(defval = false, title = 'Show Divergence Lines', group='Divergence for Many Indicators')
showpivot = input(defval = false, title = 'Show Pivot Points', group='Divergence for Many Indicators')

calcmacd = input(defval = true, title = 'MACD', group='Divergence for Many Indicators - Indicators')
calcmacda = input(defval = true, title = 'MACD Histogram', group='Divergence for Many Indicators - Indicators')
calcrsi = input(defval = true, title = 'RSI', group='Divergence for Many Indicators - Indicators')
calcstoc = input(defval = true, title = 'Stochastic', group='Divergence for Many Indicators - Indicators')
calccci = input(defval = true, title = 'CCI', group='Divergence for Many Indicators - Indicators')
calcmom = input(defval = true, title = 'Momentum', group='Divergence for Many Indicators - Indicators')
calcobv = input(defval = true, title = 'OBV', group='Divergence for Many Indicators - Indicators')
calcvwmacd = input(true, title = 'VWmacd', group='Divergence for Many Indicators - Indicators')
calccmf = input(true, title = 'Chaikin Money Flow', group='Divergence for Many Indicators - Indicators')
calcmfi = input(true, title = 'Money Flow Index', group='Divergence for Many Indicators - Indicators')
calcext = input(false, title = 'Check External Indicator', group='Divergence for Many Indicators - Indicators')
externalindi = input(defval = close, title = 'External Indicator', group='Divergence for Many Indicators - Indicators')

pos_reg_div_col = input(defval = color.yellow, title = 'Positive Regular Divergence', group='Divergence for Many Indicators - Style')
neg_reg_div_col = input(defval = color.navy, title = 'Negative Regular Divergence', group='Divergence for Many Indicators - Style')
pos_hid_div_col = input(defval = color.lime, title = 'Positive Hidden Divergence', group='Divergence for Many Indicators - Style')
neg_hid_div_col = input(defval = color.red, title = 'Negative Hidden Divergence', group='Divergence for Many Indicators - Style')
pos_div_text_col = input(defval = color.black, title = 'Positive Divergence Text Color', group='Divergence for Many Indicators - Style')
neg_div_text_col = input(defval = color.white, title = 'Negative Divergence Text Color', group='Divergence for Many Indicators - Style')
reg_div_l_style_ = input.string(defval = 'Solid', title = 'Regular Divergence Line Style', options = ['Solid', 'Dashed', 'Dotted'], group='Divergence for Many Indicators - Style')
hid_div_l_style_ = input.string(defval = 'Dashed', title = 'Hdden Divergence Line Style', options = ['Solid', 'Dashed', 'Dotted'], group='Divergence for Many Indicators - Style')
reg_div_l_width = input.int(defval = 2, title = 'Regular Divergence Line Width', minval = 1, maxval = 5, group='Divergence for Many Indicators - Style')
hid_div_l_width = input.int(defval = 1, title = 'Hidden Divergence Line Width', minval = 1, maxval = 5, group='Divergence for Many Indicators - Style')
showmas = input.bool(defval = false, title = 'Show MAs 50 & 200', inline = 'ma12', group='Divergence for Many Indicators - Style')
cma1col = input.color(defval = color.lime, title = '', inline = 'ma12', group='Divergence for Many Indicators - Style')
cma2col = input.color(defval = color.red, title = '', inline = 'ma12', group='Divergence for Many Indicators - Style')

plot(enableDivergence and showmas ? ta.sma(close, 50) : na, color = showmas ? cma1col : na, title='Divergence for Many Indicators - SMA 50', force_overlay = true)
plot(enableDivergence and showmas ? ta.sma(close, 200) : na, color = showmas ? cma2col : na, title='Divergence for Many Indicators - SMA 200', force_overlay = true)

// set line styles
var reg_div_l_style = reg_div_l_style_ == 'Solid' ? line.style_solid : reg_div_l_style_ == 'Dashed' ? line.style_dashed : line.style_dotted
var hid_div_l_style = hid_div_l_style_ == 'Solid' ? line.style_solid : hid_div_l_style_ == 'Dashed' ? line.style_dashed : line.style_dotted


// get indicators
rsi = ta.rsi(close, 14) // RSI
[macd, signal, deltamacd] = ta.macd(close, 12, 26, 9) // MACD
moment = ta.mom(close, 10) // Momentum
cci = ta.cci(close, 10) // CCI
Obv = ta.obv // OBV
stk = ta.sma(ta.stoch(close, high, low, 14), 3) // Stoch
maFast = ta.vwma(close, 12) // volume weighted macd
maSlow = ta.vwma(close, 26)
vwmacd = maFast - maSlow
Cmfm = (close - low - (high - close)) / (high - low) // Chaikin money flow
Cmfv = Cmfm * volume
cmf = ta.sma(Cmfv, 21) / ta.sma(volume, 21)
Mfi = ta.mfi(close, 14) // Money Flow Index

// keep indicators names and colors in arrays
var indicators_name = array.new_string(11)
var div_colors = array.new_color(4)
if barstate.isfirst
    // names
    array.set(indicators_name, 0, showindis == 'Full' ? 'MACD' : 'M')
    array.set(indicators_name, 1, showindis == 'Full' ? 'Hist' : 'H')
    array.set(indicators_name, 2, showindis == 'Full' ? 'RSI' : 'E')
    array.set(indicators_name, 3, showindis == 'Full' ? 'Stoch' : 'S')
    array.set(indicators_name, 4, showindis == 'Full' ? 'CCI' : 'C')
    array.set(indicators_name, 5, showindis == 'Full' ? 'MOM' : 'M')
    array.set(indicators_name, 6, showindis == 'Full' ? 'OBV' : 'O')
    array.set(indicators_name, 7, showindis == 'Full' ? 'VWMACD' : 'V')
    array.set(indicators_name, 8, showindis == 'Full' ? 'CMF' : 'C')
    array.set(indicators_name, 9, showindis == 'Full' ? 'MFI' : 'M')
    array.set(indicators_name, 10, showindis == 'Full' ? 'Extrn' : 'X')
    //colors
    array.set(div_colors, 0, pos_reg_div_col)
    array.set(div_colors, 1, neg_reg_div_col)
    array.set(div_colors, 2, pos_hid_div_col)
    array.set(div_colors, 3, neg_hid_div_col)

// Check if we get new Pivot High Or Pivot Low
float ph = ta.pivothigh(sourceDivergence == close ? close : high, prd, prd)
float pl = ta.pivotlow(sourceDivergence == close ? close : low, prd, prd)
plotshape(enableDivergence and bool(ph) and showpivot, text = 'H', style = shape.labeldown, color = color.new(color.white, 100), textcolor = color.new(color.red, 0), location = location.abovebar, offset = -prd, title='Divergence for Many Indicators - Pivot High', force_overlay = true)
plotshape(enableDivergence and bool(pl) and showpivot, text = 'L', style = shape.labelup, color = color.new(color.white, 100), textcolor = color.new(color.lime, 0), location = location.belowbar, offset = -prd, title='Divergence for Many Indicators - Pivot Low', force_overlay = true)

// keep values and positions of Pivot Highs/Lows in the arrays
var int maxarraysize = 20
var ph_positions = array.new_int(maxarraysize, 0)
var pl_positions = array.new_int(maxarraysize, 0)
var ph_vals = array.new_float(maxarraysize, 0.)
var pl_vals = array.new_float(maxarraysize, 0.)

// add PHs to the array
if bool(ph)
    array.unshift(ph_positions, bar_index)
    array.unshift(ph_vals, ph)
    if array.size(ph_positions) > maxarraysize
        array.pop(ph_positions)
        array.pop(ph_vals)

// add PLs to the array
if bool(pl)
    array.unshift(pl_positions, bar_index)
    array.unshift(pl_vals, pl)
    if array.size(pl_positions) > maxarraysize
        array.pop(pl_positions)
        array.pop(pl_vals)

// functions to check Regular Divergences and Hidden Divergences

// function to check positive regular or negative hidden divergence
// cond == 1 => positive_regular, cond == 2=> negative_hidden
positive_regular_positive_hidden_divergence(src, cond) =>
    divlen = 0
    prsc = sourceDivergence == close ? close : low
    // if indicators higher than last value and close price is higher than las close 
    if dontconfirm or src > src[1] or close > close[1]
        startpoint = dontconfirm ? 0 : 1 // don't check last candle
        // we search last 15 PPs
        for x = 0 to maxpp - 1 by 1
            len = bar_index - array.get(pl_positions, x) + prd
            // if we reach non valued array element or arrived 101. or previous bars then we don't search more
            if array.get(pl_positions, x) == 0 or len > maxbars
                break
            if len > 5 and (cond == 1 and src[startpoint] > src[len] and prsc[startpoint] < nz(array.get(pl_vals, x)) or cond == 2 and src[startpoint] < src[len] and prsc[startpoint] > nz(array.get(pl_vals, x)))
                slope1 = (src[startpoint] - src[len]) / (len - startpoint)
                virtual_line1 = src[startpoint] - slope1
                slope2 = (close[startpoint] - close[len]) / (len - startpoint)
                virtual_line2 = close[startpoint] - slope2
                arrived = true
                for y = 1 + startpoint to len - 1 by 1
                    if src[y] < virtual_line1 or nz(close[y]) < virtual_line2
                        arrived := false
                        break
                    virtual_line1 := virtual_line1 - slope1
                    virtual_line2 := virtual_line2 - slope2
                    virtual_line2

                if arrived
                    divlen := len
                    break
    divlen

// function to check negative regular or positive hidden divergence
// cond == 1 => negative_regular, cond == 2=> positive_hidden
negative_regular_negative_hidden_divergence(src, cond) =>
    divlen = 0
    prsc = sourceDivergence == close ? close : high
    // if indicators higher than last value and close price is higher than las close 
    if dontconfirm or src < src[1] or close < close[1]
        startpoint = dontconfirm ? 0 : 1 // don't check last candle
        // we search last 15 PPs
        for x = 0 to maxpp - 1 by 1
            len = bar_index - array.get(ph_positions, x) + prd
            // if we reach non valued array element or arrived 101. or previous bars then we don't search more
            if array.get(ph_positions, x) == 0 or len > maxbars
                break
            if len > 5 and (cond == 1 and src[startpoint] < src[len] and prsc[startpoint] > nz(array.get(ph_vals, x)) or cond == 2 and src[startpoint] > src[len] and prsc[startpoint] < nz(array.get(ph_vals, x)))
                slope1 = (src[startpoint] - src[len]) / (len - startpoint)
                virtual_line1 = src[startpoint] - slope1
                slope2 = (close[startpoint] - nz(close[len])) / (len - startpoint)
                virtual_line2 = close[startpoint] - slope2
                arrived = true
                for y = 1 + startpoint to len - 1 by 1
                    if src[y] > virtual_line1 or nz(close[y]) > virtual_line2
                        arrived := false
                        break
                    virtual_line1 := virtual_line1 - slope1
                    virtual_line2 := virtual_line2 - slope2
                    virtual_line2

                if arrived
                    divlen := len
                    break
    divlen

// calculate 4 types of divergence if enabled in the options and return divergences in an array
calculate_divs(cond, indicator_1) =>
    divs = array.new_int(4, 0)
    array.set(divs, 0, cond and (searchdiv == 'Regular' or searchdiv == 'Regular/Hidden') ? positive_regular_positive_hidden_divergence(indicator_1, 1) : 0)
    array.set(divs, 1, cond and (searchdiv == 'Regular' or searchdiv == 'Regular/Hidden') ? negative_regular_negative_hidden_divergence(indicator_1, 1) : 0)
    array.set(divs, 2, cond and (searchdiv == 'Hidden' or searchdiv == 'Regular/Hidden') ? positive_regular_positive_hidden_divergence(indicator_1, 2) : 0)
    array.set(divs, 3, cond and (searchdiv == 'Hidden' or searchdiv == 'Regular/Hidden') ? negative_regular_negative_hidden_divergence(indicator_1, 2) : 0)
    divs

// array to keep all divergences
var all_divergences = array.new_int(44) // 11 indicators * 4 divergence = 44 elements
// set related array elements
array_set_divs(div_pointer, index) =>
    for x = 0 to 3 by 1
        array.set(all_divergences, index * 4 + x, array.get(div_pointer, x))

// set divergences array 
if enableDivergence
    array_set_divs(calculate_divs(calcmacd, macd), 0)
    array_set_divs(calculate_divs(calcmacda, deltamacd), 1)
    array_set_divs(calculate_divs(calcrsi, rsi), 2)
    array_set_divs(calculate_divs(calcstoc, stk), 3)
    array_set_divs(calculate_divs(calccci, cci), 4)
    array_set_divs(calculate_divs(calcmom, moment), 5)
    array_set_divs(calculate_divs(calcobv, Obv), 6)
    array_set_divs(calculate_divs(calcvwmacd, vwmacd), 7)
    array_set_divs(calculate_divs(calccmf, cmf), 8)
    array_set_divs(calculate_divs(calcmfi, Mfi), 9)
    array_set_divs(calculate_divs(calcext, externalindi), 10)

// check minimum number of divergence, if less than showlimit then delete all divergence
total_div = 0
if enableDivergence
    for x = 0 to array.size(all_divergences) - 1 by 1
        total_div := total_div + math.round(math.sign(array.get(all_divergences, x)))
        total_div

    if total_div < showlimit
        array.fill(all_divergences, 0)

// keep line in an array
var pos_div_lines = array.new_line(0)
var neg_div_lines = array.new_line(0)
var pos_div_labels = array.new_label(0)
var neg_div_labels = array.new_label(0)

// remove old lines and labels if showlast option is enabled
delete_old_pos_div_lines() =>
    if enableDivergence and array.size(pos_div_lines) > 0
        for j = 0 to array.size(pos_div_lines) - 1 by 1
            line.delete(array.get(pos_div_lines, j))
        array.clear(pos_div_lines)

delete_old_neg_div_lines() =>
    if enableDivergence and array.size(neg_div_lines) > 0
        for j = 0 to array.size(neg_div_lines) - 1 by 1
            line.delete(array.get(neg_div_lines, j))
        array.clear(neg_div_lines)

delete_old_pos_div_labels() =>
    if enableDivergence and array.size(pos_div_labels) > 0
        for j = 0 to array.size(pos_div_labels) - 1 by 1
            label.delete(array.get(pos_div_labels, j))
        array.clear(pos_div_labels)

delete_old_neg_div_labels() =>
    if enableDivergence and array.size(neg_div_labels) > 0
        for j = 0 to array.size(neg_div_labels) - 1 by 1
            label.delete(array.get(neg_div_labels, j))
        array.clear(neg_div_labels)

// delete last creted lines and labels until we met new PH/PV 
delete_last_pos_div_lines_label(n) =>
    if enableDivergence and n > 0 and array.size(pos_div_lines) >= n
        asz = array.size(pos_div_lines)
        for j = 1 to n by 1
            line.delete(array.get(pos_div_lines, asz - j))
            array.pop(pos_div_lines)
        if array.size(pos_div_labels) > 0
            label.delete(array.get(pos_div_labels, array.size(pos_div_labels) - 1))
            array.pop(pos_div_labels)

delete_last_neg_div_lines_label(n) =>
    if enableDivergence and n > 0 and array.size(neg_div_lines) >= n
        asz = array.size(neg_div_lines)
        for j = 1 to n by 1
            line.delete(array.get(neg_div_lines, asz - j))
            array.pop(neg_div_lines)
        if array.size(neg_div_labels) > 0
            label.delete(array.get(neg_div_labels, array.size(neg_div_labels) - 1))
            array.pop(neg_div_labels)

// variables for Alerts
pos_reg_div_detected = false
neg_reg_div_detected = false
pos_hid_div_detected = false
neg_hid_div_detected = false

// to remove lines/labels until we met new // PH/PL
var last_pos_div_lines = 0
var last_neg_div_lines = 0
var remove_last_pos_divs = false
var remove_last_neg_divs = false
if bool(pl)
    remove_last_pos_divs := false
    last_pos_div_lines := 0
    last_pos_div_lines
if bool(ph)
    remove_last_neg_divs := false
    last_neg_div_lines := 0
    last_neg_div_lines

// draw divergences lines and labels
divergence_text_top = ''
divergence_text_bottom = ''
distances = array.new_int(0)
dnumdiv_top = 0
dnumdiv_bottom = 0
top_label_col = color.white
bottom_label_col = color.white
old_pos_divs_can_be_removed = true
old_neg_divs_can_be_removed = true
startpoint = dontconfirm ? 0 : 1 // used for don't confirm option
if enableDivergence
    for x = 0 to 10 by 1
        div_type = -1
        for y = 0 to 3 by 1
            if array.get(all_divergences, x * 4 + y) > 0 // any divergence?
                div_type := y
                if y % 2 == 1
                    dnumdiv_top := dnumdiv_top + 1
                    top_label_col := array.get(div_colors, y)
                    top_label_col
                if y % 2 == 0
                    dnumdiv_bottom := dnumdiv_bottom + 1
                    bottom_label_col := array.get(div_colors, y)
                    bottom_label_col
                if not array.includes(distances, array.get(all_divergences, x * 4 + y)) // line not exist ?
                    array.push(distances, array.get(all_divergences, x * 4 + y))
                    new_line = enableDivergence and showlines ? line.new(x1 = bar_index - array.get(all_divergences, x * 4 + y), y1 = sourceDivergence == close ? close[array.get(all_divergences, x * 4 + y)] : y % 2 == 0 ? low[array.get(all_divergences, x * 4 + y)] : high[array.get(all_divergences, x * 4 + y)], x2 = bar_index - startpoint, y2 = sourceDivergence == close ? close[startpoint] : y % 2 == 0 ? low[startpoint] : high[startpoint], color = array.get(div_colors, y), style = y < 2 ? reg_div_l_style : hid_div_l_style, width = y < 2 ? reg_div_l_width : hid_div_l_width, force_overlay = true) : na
                    if y % 2 == 0
                        if old_pos_divs_can_be_removed
                            old_pos_divs_can_be_removed := false
                            if not showlast and remove_last_pos_divs
                                delete_last_pos_div_lines_label(last_pos_div_lines)
                                last_pos_div_lines := 0
                                last_pos_div_lines
                            if showlast
                                delete_old_pos_div_lines()
                        array.push(pos_div_lines, new_line)
                        last_pos_div_lines := last_pos_div_lines + 1
                        remove_last_pos_divs := true
                        remove_last_pos_divs

                    if y % 2 == 1
                        if old_neg_divs_can_be_removed
                            old_neg_divs_can_be_removed := false
                            if not showlast and remove_last_neg_divs
                                delete_last_neg_div_lines_label(last_neg_div_lines)
                                last_neg_div_lines := 0
                                last_neg_div_lines
                            if showlast
                                delete_old_neg_div_lines()
                        array.push(neg_div_lines, new_line)
                        last_neg_div_lines := last_neg_div_lines + 1
                        remove_last_neg_divs := true
                        remove_last_neg_divs

                // set variables for alerts
                if y == 0
                    pos_reg_div_detected := true
                    pos_reg_div_detected
                if y == 1
                    neg_reg_div_detected := true
                    neg_reg_div_detected
                if y == 2
                    pos_hid_div_detected := true
                    pos_hid_div_detected
                if y == 3
                    neg_hid_div_detected := true
                    neg_hid_div_detected
        // get text for labels
        if div_type >= 0
            divergence_text_top := divergence_text_top + (div_type % 2 == 1 ? showindis != 'Don\'t Show' ? array.get(indicators_name, x) + '\n' : '' : '')
            divergence_text_bottom := divergence_text_bottom + (div_type % 2 == 0 ? showindis != 'Don\'t Show' ? array.get(indicators_name, x) + '\n' : '' : '')
            divergence_text_bottom


// draw labels
if enableDivergence and (showindis != 'Don\'t Show' or shownum)
    if shownum and dnumdiv_top > 0
        divergence_text_top := divergence_text_top + str.tostring(dnumdiv_top)
        divergence_text_top
    if shownum and dnumdiv_bottom > 0
        divergence_text_bottom := divergence_text_bottom + str.tostring(dnumdiv_bottom)
        divergence_text_bottom
    if divergence_text_top != ''
        if showlast
            delete_old_neg_div_labels()
        array.push(neg_div_labels, label.new(x = bar_index, y = math.max(high, high[1]), text = divergence_text_top, color = top_label_col, textcolor = neg_div_text_col, style = label.style_label_down, force_overlay = true))

    if divergence_text_bottom != ''
        if showlast
            delete_old_pos_div_labels()
        array.push(pos_div_labels, label.new(x = bar_index, y = math.min(low, low[1]), text = divergence_text_bottom, color = bottom_label_col, textcolor = pos_div_text_col, style = label.style_label_up, force_overlay = true))

alertcondition(enableDivergence and pos_reg_div_detected, title = 'Divergence - Positive Regular Divergence Detected', message = 'Positive Regular Divergence Detected')
alertcondition(enableDivergence and neg_reg_div_detected, title = 'Divergence - Negative Regular Divergence Detected', message = 'Negative Regular Divergence Detected')
alertcondition(enableDivergence and pos_hid_div_detected, title = 'Divergence - Positive Hidden Divergence Detected', message = 'Positive Hidden Divergence Detected')
alertcondition(enableDivergence and neg_hid_div_detected, title = 'Divergence - Negative Hidden Divergence Detected', message = 'Negative Hidden Divergence Detected')

alertcondition(enableDivergence and (pos_reg_div_detected or pos_hid_div_detected), title = 'Divergence - Positive Divergence Detected', message = 'Positive Divergence Detected')
alertcondition(enableDivergence and (neg_reg_div_detected or neg_hid_div_detected), title = 'Divergence - Negative Divergence Detected', message = 'Negative Divergence Detected')

//-----------------------------------------------------------------------------}

// ===============================================================================================================
// === Ichimoku Cloud (Built-in TradingView Indicator) ===
// Source: https://www.tradingview.com/support/solutions/43000502040/
// Property of TradingView, used and modified per TradingView's platform terms.
// Note: Modified to improve visuals.
// Note: The Ichimoku Cloud may repaint due to its forward-projected Senkou Span lines; adjust settings (e.g., projection periods) to mitigate if needed. Check settings for any additional behavioral considerations introduced by modifications.

// Input Parameters
conversionPeriods = input.int(9, minval=1, title="Conversion Line Length", group="Ichimoku")
basePeriods = input.int(26, minval=1, title="Base Line Length", group="Ichimoku")
laggingSpan2Periods = input.int(52, minval=1, title="Leading Span B Length", group="Ichimoku")
displacement = input.int(26, minval=1, title="Lagging Span", group="Ichimoku")

// Calculations
donchian(len) => math.avg(ta.lowest(len), ta.highest(len))
conversionLine = donchian(conversionPeriods)
baseLine = donchian(basePeriods)
leadLine1 = math.avg(conversionLine, baseLine)
leadLine2 = donchian(laggingSpan2Periods)

// Plotting
plot(enableIchimoku ? conversionLine : na, color=#2962FF, title="Ichimoku - Conversion Line", display=display.none, force_overlay=true)
plot(enableIchimoku ? baseLine : na, color=#B71C1C, title="Ichimoku - Base Line", display=display.none, force_overlay=true)
plot(enableIchimoku ? close : na, offset=-displacement + 1, color=#43A047, title="Ichimoku - Lagging Span", display=display.none, force_overlay=true)
p1 = plot(enableIchimoku ? leadLine1 : na, offset=displacement - 1, color=#A5D6A7, title="Ichimoku - Leading Span A", force_overlay=true)
p2 = plot(enableIchimoku ? leadLine2 : na, offset=displacement - 1, color=#EF9A9A, title="Ichimoku - Leading Span B", force_overlay=true)
plot(enableIchimoku ? (leadLine1 > leadLine2 ? leadLine1 : leadLine2) : na, offset=displacement - 1, title="Ichimoku - Kumo Cloud Upper Line", display=display.none, force_overlay=true)
plot(enableIchimoku ? (leadLine1 < leadLine2 ? leadLine1 : leadLine2) : na, offset=displacement - 1, title="Ichimoku - Kumo Cloud Lower Line", display=display.none, force_overlay=true)

// Fill Kumo Cloud
fill(p1, p2, color=enableIchimoku ? (leadLine1 > leadLine2 ? color.rgb(67, 160, 71, 90) : color.rgb(244, 67, 54, 90)) : na)
//-----------------------------------------------------------------------------}