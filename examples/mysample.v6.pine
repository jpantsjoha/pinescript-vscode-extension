//@version=6
strategy("TradingAlpha • Point-Clip Strategy v1.2 (Pine v6)", overlay=true, calc_on_order_fills=true, calc_on_every_tick=false, pyramiding=0, initial_capital=10000, commission_type=strategy.commission.percent, commission_value=0.01)

// Inputs (mirrors indicator where relevant)
volLen   = input.int(20, "Volume MA Length")
volMult  = input.float(2,  "Volume Spike Multiplier", step=0.1)
rangeLen = input.int(30, "Range Lookback (bars)")
useORB   = input.bool(true, "Use Opening Range")
orbMin   = input.int(30, "ORB Minutes", minval=5)
brkType  = input.string("RangeHighLow", "Breakout Type", options=["RangeHighLow","PrevBar","VWAP","AVWAP_Open"])

useTrend   = input.bool(true, "Use LTF Trend (EMA 20/50)")
emaFastLen = input.int(20, "EMA Fast")
emaSlowLen = input.int(50, "EMA Slow")
useHTF     = input.bool(true, "Use Higher-TF Confirm")
htfTF      = input.timeframe("15", "HTF (minutes)")
htfEMA     = input.int(50, "HTF EMA Length")

useEngulf  = input.bool(true,  "Engulfing on")
useHammer  = input.bool(false, "Hammer/Star on")
useDoji    = input.bool(false, "Trend-Doji on")
dojiBody   = input.float(0.25, "Max Doji Body %")

useSess    = input.bool(true, "Filter by Sessions")
sess1      = input.session("0800-1030", "Session 1 (BST)")
sess2      = input.session("1430-1600", "Session 2 (BST)")

wVol       = input.float(0.45, "Weight: Volume", step=0.05)
wTrend     = input.float(0.35, "Weight: Trend", step=0.05)
wStruct    = input.float(0.20, "Weight: Structure/Pattern", step=0.05)
minLong    = input.float(0.65, "Min Score LONG", step=0.05)
minShort   = input.float(0.65, "Min Score SHORT", step=0.05)

tpPct      = input.float(1.0, "Take Profit % of price", step=0.1)   // 0.8–1.5 typical
slPct      = input.float(0.45,"Stop Loss % of price", step=0.05)    // 0.3–0.5 typical
useVWAPtrl = input.bool(false, "Trail by VWAP (long above / short below)")
riskPct    = input.float(10, "Position size % of equity (backtest sizing)")

// Helpers
inSession(sessionStr) =>
    not na(time(timeframe.period, sessionStr))
clamp01(x) =>
    math.min(1.0, math.max(0.0, x))

// Series
vol    = volume
volMA  = ta.sma(vol, volLen)
vSpike = vol > volMA * volMult

emaF = ta.ema(close, emaFastLen)
emaS = ta.ema(close, emaSlowLen)
trUp = emaF > emaS
trDn = emaF < emaS

htfClose = request.security(syminfo.tickerid, htfTF, close)
htfEma   = request.security(syminfo.tickerid, htfTF, ta.ema(close, htfEMA))
htfUp    = htfClose > htfEma
htfDn    = htfClose < htfEma

vwap = ta.vwap

// AVWAP (session anchored)
var float cumPV = na
var float cumV = na
var float avwap = na
inS1 = not useSess or inSession(sess1)
inS2 = not useSess or inSession(sess2)
inSess = inS1 or inS2
var bool prevInSess = false
newSessStart = inSess and not prevInSess[1]
if newSessStart
    cumPV := close * volume
    cumV  := volume
else
    cumPV := nz(cumPV) + close * volume
    cumV  := nz(cumV)  + volume
avwap := cumV > 0 ? cumPV / cumV : na
prevInSess := inSess

// Range & ORB
rHigh = ta.highest(high, rangeLen)
rLow  = ta.lowest(low, rangeLen)
tfSec   = timeframe.in_seconds(timeframe.period)
orbBars = math.max(1, math.round(orbMin * 60.0 / tfSec))
var int  orbStartIndex = na
var float orbH = na
var float orbL = na
if newSessStart
    orbStartIndex := bar_index, orbH := high, orbL := low
orbActive = useORB and inSess and not na(orbStartIndex) and (bar_index - orbStartIndex < orbBars)
if orbActive
    orbH := math.max(orbH, high)
    orbL := math.min(orbL, low)

// Breakouts
brPrevUp   = close > high[1]
brPrevDn   = close < low[1]
brRangeUp  = close > rHigh
brRangeDn  = close < rLow
brVWAPUp   = close > vwap and close[1] <= vwap
brVWAPDn   = close < vwap and close[1] >= vwap
brAVWAPUp  = close > avwap and close[1] <= avwap
brAVWAPDn  = close < avwap and close[1] >= avwap
brORBUp    = (not orbActive) and not na(orbH) and close > orbH
brORBDn    = (not orbActive) and not na(orbL) and close < orbL

longBrk = false
shortBrk = false
if brkType == "PrevBar"
    longBrk := brPrevUp
    shortBrk := brPrevDn
else if brkType == "RangeHighLow"
    longBrk := brRangeUp or brORBUp
    shortBrk := brRangeDn or brORBDn
else if brkType == "VWAP"
    longBrk := brVWAPUp
    shortBrk := brVWAPDn
else
    longBrk := brAVWAPUp
    shortBrk := brAVWAPDn

// Patterns
rng   = high - low
body  = math.abs(close - open)
uW    = high - math.max(close, open)
lW    = math.min(close, open) - low
bullE = (close > open) and (close[1] < open[1]) and (close >= open[1]) and (open <= close[1])
bearE = (close < open) and (close[1] > open[1]) and (close <= open[1]) and (open >= close[1])
isHammer = rng > 0 and lW/rng >= 0.5 and body/rng <= 0.35
isStar   = rng > 0 and uW/rng >= 0.5 and body/rng <= 0.35
isDoji   = rng > 0 ? (body/rng) <= dojiBody : false

allowLongPat  = (not useEngulf and not useHammer and not useDoji) or (useEngulf and bullE) or (useHammer and isHammer) or (useDoji and isDoji and trUp)
allowShortPat = (not useEngulf and not useHammer and not useDoji) or (useEngulf and bearE) or (useHammer and isStar)   or (useDoji and isDoji and trDn)

// Trend OK
trendOK_L = useTrend ? (trUp and (not useHTF or htfUp)) : (not useHTF or htfUp)
trendOK_S = useTrend ? (trDn and (not useHTF or htfDn)) : (not useHTF or htfDn)

// Scoring
volRatio = volMA > 0 ? (vol/volMA) : 1.0
volScore = clamp01((volRatio - 1.0) / math.max(0.0001, volMult - 1.0))
trendScoreL = clamp01((trUp?0.6:0.0) + ((useHTF and htfUp)?0.4:(useHTF?0.0:0.4)))
trendScoreS = clamp01((trDn?0.6:0.0) + ((useHTF and htfDn)?0.4:(useHTF?0.0:0.4)))
structL = (longBrk ? 0.7:0.0) + (allowLongPat?0.3:0.0)
structS = (shortBrk?0.7:0.0) + (allowShortPat?0.3:0.0)
scoreL = wVol*volScore + wTrend*trendScoreL + wStruct*structL
scoreS = wVol*volScore + wTrend*trendScoreS + wStruct*structS

sessionOK = inSess
longSig  = barstate.isconfirmed and sessionOK and vSpike and longBrk  and allowLongPat  and scoreL >= minLong and trendOK_L
shortSig = barstate.isconfirmed and sessionOK and vSpike and shortBrk and allowShortPat and scoreS >= minShort and trendOK_S

// Orders
posSize = strategy.equity * (riskPct/100.0) / close
if longSig and strategy.position_size <= 0
    strategy.entry("L", strategy.long, qty=posSize)
if shortSig and strategy.position_size >= 0
    strategy.entry("S", strategy.short, qty=posSize)

longSL  = strategy.position_avg_price * (1 - slPct/100.0)
longTP  = strategy.position_avg_price * (1 + tpPct/100.0)
shortSL = strategy.position_avg_price * (1 + slPct/100.0)
shortTP = strategy.position_avg_price * (1 - tpPct/100.0)

if useVWAPtrl and strategy.position_size > 0
    longSL := math.max(longSL, vwap*0.999)
if useVWAPtrl and strategy.position_size < 0
    shortSL := math.min(shortSL, vwap*1.001)

strategy.exit("L-Exit", "L", stop=longSL, limit=longTP)
strategy.exit("S-Exit", "S", stop=shortSL, limit=shortTP)

// Visual cues (optional)
plot(vwap, "VWAP", color=color.new(color.blue, 0))
plot(avwap,"AVWAP",color=color.new(color.teal, 0))
plotshape(longSig,  title="LONG",  style=shape.triangleup,   color=color.new(color.green,0), location=location.belowbar, text="L", size=size.tiny)
plotshape(shortSig, title="SHORT", style=shape.triangledown, color=color.new(color.red,0),   location=location.abovebar, text="S", size=size.tiny)

